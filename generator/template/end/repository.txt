package repository

import (
	"context"
	"end/bootstrap"
	"end/model"
	"gorm.io/gorm"
)

type {{ .MethodName }}Repository[T model.{{ .MethodName }}] interface {
	// 实现通用Mapper
	Repository[T]

	// 自己实现的接口
	GetList(context.Context, model.PageDomain[T])*RepoResData
}

type {{ .ValName }}Repository struct {
	BaseRepository[model.{{ .MethodName }}]
}

func New{{ .MethodName }}Repository(app *bootstrap.App) {{ .MethodName }}Repository[model.{{ .MethodName }}] {
	repository := &{{ .ValName }}Repository{}
	repository.App = app
	return repository
}

func (r {{ .ValName }}Repository) GetList(ctx context.Context,p model.PageDomain[model.{{ .MethodName }}])*RepoResData{
	db := r.App.DBClient.(*bootstrap.MySqlClient).DB

	var tList model.ListDomain[model.{{ .MethodName }}]
	var ts []*model.{{ .MethodName }}
	var total int64

	condition := db.Model(model.{{ .MethodName }}{})

    {{ range $index, $element := .Conditions -}}
    if p.Condition.{{ $element.Name }}!={{if eq (index $element.Type 0 ) '*'}}nil{{ else }}""{{ end }}{
    		condition.Where("{{ $element.LowerName }} = ?",p.Condition.{{ $element.Name }})
    }
    {{ end }}
	condition.Count(&total)
	if condition.Error!=nil  && condition.Error!=gorm.ErrRecordNotFound{
		return RepoResp(UNKNOWN,condition.Error)
	}
	condition.Scopes(model.Paginate(p.PageNo,p.PageSize)).Find(&ts)

	tList.List = ts
	tList.Total = total

	return RepoResp(OK,&tList)
}